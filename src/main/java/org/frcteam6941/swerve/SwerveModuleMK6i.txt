package org.frcteam6941.swerve;

import org.frcteam1678.lib.util.CTREModuleState;

import com.ctre.phoenix6.BaseStatusSignal;
import com.ctre.phoenix6.hardware.CANcoder;
import com.ctre.phoenix6.hardware.TalonFX;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModule;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModule.DriveRequestType;
import com.ctre.phoenix6.mechanisms.swerve.SwerveModuleConstants;

import edu.wpi.first.math.kinematics.SwerveModulePosition;
import edu.wpi.first.math.kinematics.SwerveModuleState;
import edu.wpi.first.math.geometry.Rotation2d;

public class SwerveModuleMK6i implements SwerveModuleBase {
    private Double recordAngle = null;

    private TalonFX angleMotor;
    private TalonFX driveMotor;
    private CANcoder angleEncoder;
    
    private SwerveModuleConstants constants;

    /**
     * Constructor function for the module.
     * 
     * @param moduleNumber The number of the module. This will be correspondent to
     *                     the position of its {@link Translation2d}
     *                     in {@link SwerveDriveKinematics}.
     * @param driveMotorID CAN ID of the falcon drive motor.
     * @param angleMotorID CAN ID of the 775pro turning motor along with the
     *                     TalonSRX motor controller.
     * @param angleOffset  Angle offset for the encoder in degrees.
     */
    public SwerveModuleMK6i(int moduleNumber, SwerveModuleConstants constants, String canbusName) {
        // TODO: write constructor
		
        this.constants =  constants;
        /* Angle Motor Config */
		angleMotor = new TalonFX(constants.SteerMotorId, canbusName);
        configAngleMotor();

        /* Drive Motor Config */
        driveMotor = new TalonFX(constants.DriveMotorId, canbusName);
        configDriveMotor();

    }

    /**
     * Core function to set the state of the swerve module.
     * 
     * @param desiredState   The desired state of the module.
     * @param isOpenLoop     Whether the speed control will be open loop (voltage
     *                       control), or close loop (using on-board PIDF control to
     *                       reach the velocity set point).
     * @param overrideMotion Enable angle control even if the speed is lower than
     *                       the limit. Usually used for BRAKE mode settings.
     */
    @Override
    public void setDesiredState(SwerveModuleState desiredState, boolean isOpenLoop, boolean overrideMotion) {
        SwerveModuleState optimizedState = CTREModuleState.optimize(
            desiredState,
            Rotation2d.fromDegrees(this.getEncoderUnbound().getDegrees())
        );
        if (isOpenLoop) {
            driveMotor.set(ControlMode.PercentOutput, optimizedState.speedMetersPerSecond);
        } else {
            double velocity = Conversions.MPSToFalcon(
                optimizedState.speedMetersPerSecond,
                drivetrainConstants.getWheelCircumferenceMeters(),
                drivetrainConstants.getDriveGearRatio()
            );
            driveMotor.set(ControlMode.Velocity, velocity);
        }

        boolean inMotion; // Preventing jittering and useless resetting.
        if (isOpenLoop) {
            inMotion = Math.abs(optimizedState.speedMetersPerSecond) >= drivetrainConstants.getDeadband();
        } else {
            inMotion = Math.abs(optimizedState.speedMetersPerSecond) >= (drivetrainConstants.getFreeSpeedMetersPerSecond() * drivetrainConstants.getDeadband());
        }

        if (inMotion || overrideMotion) {
            double target = optimizedState.angle.getDegrees();
            angleMotor.set(ControlMode.Position, (target + moduleConstants.getAngleOffsetDegreesCCW()) / 360.0 * 4096.0);
            recordAngle = null;
        } else {
            if (recordAngle == null) {
                recordAngle = (this.getEncoderUnbound().getDegrees() + moduleConstants.getAngleOffsetDegreesCCW()) / 360.0 * 4096.0;
            }
            angleMotor.set(ControlMode.Position, recordAngle);
        }
    }

    /** Configurations for the angle motor. */
    private void configAngleMotor() {
        angleMotor.getConfigurator().apply(constants.SteerMotorInitialConfigs);
    }

    /** Configurations for the drive motor. */
    private void configDriveMotor() {
        driveMotor.getConfigurator().apply(constants.DriveMotorInitialConfigs);
        
    }

    /**
     * Get the Encoder angle within 0 to 360 degrees.
     * 
     * @return The normalized angle of the encoder in degrees.
     */
    private Rotation2d getEncoder() {
        return Rotation2d.fromDegrees(AngleNormalization.getAbsoluteAngleDegree(getEncoderUnbound().getDegrees()));
    }

    /**
     * Get the Encoder angle unbound (maybe greater than 360 or lower than 0) with
     * angle offset calculated.
     * 
     * @return The raw angle of the encoder in degrees.
     */
    private Rotation2d getEncoderUnbound() {
        return Rotation2d.fromDegrees(
                Conversions4096.falconToDegrees(angleMotor.getSelectedSensorPosition(), 1.0) - moduleConstants.getAngleOffsetDegreesCCW());
    }

    /**
     * Get the state of the module.
     * 
     * @return The state of the module.
     */
    @Override
    public SwerveModuleState getState() {
        double velocity = Conversions.falconToMPS(driveMotor.getSelectedSensorVelocity(), drivetrainConstants.getWheelCircumferenceMeters(), drivetrainConstants.getDriveGearRatio());
        Rotation2d angle = getEncoder();
        return new SwerveModuleState(velocity, angle);
    }

    @Override
    public int getModuleNumber() {
        return moduleConstants.getModuleNumber();
    }

    @Override
    public double getTick() {
        return driveMotor.getSelectedSensorPosition();
    }
}
